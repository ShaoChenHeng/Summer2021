{"remainingRequest":"/home/scheng/.emacs.d/site-lisp/emacs-application-framework/app/vue-demo/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/scheng/.emacs.d/site-lisp/emacs-application-framework/app/vue-demo/src/components/dynamicPolygon.vue?vue&type=script&lang=js&","dependencies":[{"path":"/home/scheng/.emacs.d/site-lisp/emacs-application-framework/app/vue-demo/src/components/dynamicPolygon.vue","mtime":1626949065814},{"path":"/home/scheng/.emacs.d/site-lisp/emacs-application-framework/app/vue-demo/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/scheng/.emacs.d/site-lisp/emacs-application-framework/app/vue-demo/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/home/scheng/.emacs.d/site-lisp/emacs-application-framework/app/vue-demo/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/scheng/.emacs.d/site-lisp/emacs-application-framework/app/vue-demo/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCBUd2VlbkxpdGUgZnJvbSAnZ3NhcCcKZXhwb3J0IGRlZmF1bHQgewogICAgbmFtZTogJ2R5bmFtaWNQb2x5Z29uJywKCiAgICBkYXRhOiBmdW5jdGlvbigpIHsKICAgICAgICB2YXIgZGVmYXVsdFNpZGVzID0gMTA7CiAgICAgICAgdmFyIHN0YXRzID0gQXJyYXkuYXBwbHkobnVsbCwgeyBsZW5ndGg6IGRlZmF1bHRTaWRlcyB9KS5tYXAoCiAgICAgICAgICAgIGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgcmV0dXJuIDEwMDsKICAgICAgICAgICAgfQogICAgICAgICk7CgogICAgICAgIHJldHVybiB7CiAgICAgICAgICAgIHN0YXRzOiBzdGF0cywKICAgICAgICAgICAgcG9pbnRzOiBnZW5lcmF0ZVBvaW50cyhzdGF0cyksCiAgICAgICAgICAgIHNpZGVzOiBkZWZhdWx0U2lkZXMsCiAgICAgICAgICAgIG1pblJhZGl1czogNTAsCiAgICAgICAgICAgIGludGVydmFsOiBudWxsLAogICAgICAgICAgICB1cGRhdGVJbnRlcnZhbDogNTAwCiAgICAgICAgfTsKICAgIH0sCgogICAgd2F0Y2g6IHsKICAgICAgICBzaWRlczogZnVuY3Rpb24obmV3U2lkZXMsIG9sZFNpZGVzKSB7CiAgICAgICAgdmFyIHNpZGVzRGlmZmVyZW5jZSA9IG5ld1NpZGVzIC0gb2xkU2lkZXM7CiAgICAgICAgaWYgKHNpZGVzRGlmZmVyZW5jZSA+IDApIHsKICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gc2lkZXNEaWZmZXJlbmNlOyBpKyspIHsKICAgICAgICAgICAgdGhpcy5zdGF0cy5wdXNoKHRoaXMubmV3UmFuZG9tVmFsdWUoKSk7CiAgICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB2YXIgYWJzb2x1dGVTaWRlc0RpZmZlcmVuY2UgPSBNYXRoLmFicyhzaWRlc0RpZmZlcmVuY2UpOwogICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBhYnNvbHV0ZVNpZGVzRGlmZmVyZW5jZTsgaSsrKSB7CiAgICAgICAgICAgIHRoaXMuc3RhdHMuc2hpZnQoKTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICB9LAogICAgICAgIHN0YXRzOiBmdW5jdGlvbihuZXdTdGF0cykgewogICAgICAgICAgICBUd2VlbkxpdGUudG8odGhpcy4kZGF0YSwgdGhpcy51cGRhdGVJbnRlcnZhbCAvIDEwMDAsIHsKICAgICAgICAgICAgICAgIHBvaW50czogZ2VuZXJhdGVQb2ludHMobmV3U3RhdHMpCiAgICAgICAgICAgIH0pOwogICAgICAgIH0sCiAgICAgICAgdXBkYXRlSW50ZXJ2YWw6IGZ1bmN0aW9uKCkgewogICAgICAgICAgICB0aGlzLnJlc2V0SW50ZXJ2YWwoKTsKICAgICAgICB9CiAgICB9LAoKCiAgICBtb3VudGVkOiBmdW5jdGlvbigpIHsKICAgICAgICB0aGlzLnJlc2V0SW50ZXJ2YWwoKTsKICAgIH0sCgoKICAgIG1ldGhvZHM6IHsKICAgICAgICByYW5kb21pemVTdGF0czogZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHZhciB2bSA9IHRoaXM7CiAgICAgICAgICAgIHRoaXMuc3RhdHMgPSB0aGlzLnN0YXRzLm1hcChmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgIHJldHVybiB2bS5uZXdSYW5kb21WYWx1ZSgpOwogICAgICAgICAgICB9KTsKICAgICAgICB9LAogICAgICAgIG5ld1JhbmRvbVZhbHVlOiBmdW5jdGlvbigpIHsKICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbCgKICAgICAgICAgICAgICAgIHRoaXMubWluUmFkaXVzICsgTWF0aC5yYW5kb20oKSAqICgxMDAgLSB0aGlzLm1pblJhZGl1cykKICAgICAgICAgICAgKTsKICAgICAgICB9LAogICAgICAgIHJlc2V0SW50ZXJ2YWw6IGZ1bmN0aW9uKCkgewogICAgICAgICAgICB2YXIgdm0gPSB0aGlzOwogICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWwpOwogICAgICAgICAgICB0aGlzLnJhbmRvbWl6ZVN0YXRzKCk7CiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgIHZtLnJhbmRvbWl6ZVN0YXRzKCk7CiAgICAgICAgICAgIH0sIHRoaXMudXBkYXRlSW50ZXJ2YWwpOwogICAgICAgIH0KICAgIH0sCgogICAgIAoKfQoKCmZ1bmN0aW9uIHZhbHVlVG9Qb2ludCh2YWx1ZSwgaW5kZXgsIHRvdGFsKSB7CiAgICB2YXIgeCA9IDA7CiAgICB2YXIgeSA9IC12YWx1ZSAqIDAuOTsKICAgIHZhciBhbmdsZSA9ICgoTWF0aC5QSSAqIDIpIC8gdG90YWwpICogaW5kZXg7CiAgICB2YXIgY29zID0gTWF0aC5jb3MoYW5nbGUpOwogICAgdmFyIHNpbiA9IE1hdGguc2luKGFuZ2xlKTsKICAgIHZhciB0eCA9IHggKiBjb3MgLSB5ICogc2luICsgMTAwOwogICAgdmFyIHR5ID0geCAqIHNpbiArIHkgKiBjb3MgKyAxMDA7CiAgICByZXR1cm4geyB4OiB0eCwgeTogdHkgfTsKfQoKZnVuY3Rpb24gZ2VuZXJhdGVQb2ludHMoc3RhdHMpIHsKICAgIHZhciB0b3RhbCA9IHN0YXRzLmxlbmd0aDsKICAgIHJldHVybiBzdGF0cyAubWFwKGZ1bmN0aW9uKHN0YXQsIGluZGV4KSB7CiAgICAgICAgdmFyIHBvaW50ID0gdmFsdWVUb1BvaW50KHN0YXQsIGluZGV4LCB0b3RhbCk7CiAgICAgICAgcmV0dXJuIHBvaW50LnggKyAiLCIgKyBwb2ludC55OwogICAgfSkgLmpvaW4oIiAiKTsKfQoKCg=="},{"version":3,"sources":["dynamicPolygon.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAoBA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA","file":"dynamicPolygon.vue","sourceRoot":"src/components","sourcesContent":["<template>\n   \n    <div id=\"app\">\n        <svg width=\"200\" height=\"200\">\n            <polygon :points=\"points\"></polygon>\n            <circle cx=\"100\" cy=\"100\" r=\"90\"></circle>\n        </svg>\n\n        <label> Sides : {{sides}} </label>\n        <input type=\"range\" min=\"3\" max=\"500\" v-model.number=\"sides\" />\n        <label>Minimum Radius: {{minRadius}} % </label>\n        <input type=\"range\" min=\"0\" max=\"90\" v-model.number=\"minRadius\" />\n        <label>Update Interval: {{ updateInterval }} milliseconds</label>\n        <input type=\"range\" min=\"10\" max=\"2000\" v-model.number=\"updateInterval\" />\n    </div>\n    \n</template>\n\n\n<script>\nimport TweenLite from 'gsap'\nexport default {\n    name: 'dynamicPolygon',\n\n    data: function() {\n        var defaultSides = 10;\n        var stats = Array.apply(null, { length: defaultSides }).map(\n            function() {\n                return 100;\n            }\n        );\n\n        return {\n            stats: stats,\n            points: generatePoints(stats),\n            sides: defaultSides,\n            minRadius: 50,\n            interval: null,\n            updateInterval: 500\n        };\n    },\n\n    watch: {\n        sides: function(newSides, oldSides) {\n        var sidesDifference = newSides - oldSides;\n        if (sidesDifference > 0) {\n            for (var i = 1; i <= sidesDifference; i++) {\n            this.stats.push(this.newRandomValue());\n            }\n        } else {\n            var absoluteSidesDifference = Math.abs(sidesDifference);\n            for (var i = 1; i <= absoluteSidesDifference; i++) {\n            this.stats.shift();\n            }\n        }\n        },\n        stats: function(newStats) {\n            TweenLite.to(this.$data, this.updateInterval / 1000, {\n                points: generatePoints(newStats)\n            });\n        },\n        updateInterval: function() {\n            this.resetInterval();\n        }\n    },\n\n\n    mounted: function() {\n        this.resetInterval();\n    },\n\n\n    methods: {\n        randomizeStats: function() {\n            var vm = this;\n            this.stats = this.stats.map(function() {\n                return vm.newRandomValue();\n            });\n        },\n        newRandomValue: function() {\n            return Math.ceil(\n                this.minRadius + Math.random() * (100 - this.minRadius)\n            );\n        },\n        resetInterval: function() {\n            var vm = this;\n            clearInterval(this.interval);\n            this.randomizeStats();\n            this.interval = setInterval(function() {\n                vm.randomizeStats();\n            }, this.updateInterval);\n        }\n    },\n\n     \n\n}\n\n\nfunction valueToPoint(value, index, total) {\n    var x = 0;\n    var y = -value * 0.9;\n    var angle = ((Math.PI * 2) / total) * index;\n    var cos = Math.cos(angle);\n    var sin = Math.sin(angle);\n    var tx = x * cos - y * sin + 100;\n    var ty = x * sin + y * cos + 100;\n    return { x: tx, y: ty };\n}\n\nfunction generatePoints(stats) {\n    var total = stats.length;\n    return stats .map(function(stat, index) {\n        var point = valueToPoint(stat, index, total);\n        return point.x + \",\" + point.y;\n    }) .join(\" \");\n}\n\n\n</script>\n\n<style>\n    svg {\n        display: block;\n    }\n    \n    polygon {\n        fill: #41b883;\n    }\n    circle {\n        fill: transparent;\n        stroke: #35495e;\n    }\n    input[type=\"range\"] {\n        display: block;\n        width: 25%;\n        margin-bottom: 15px;\n    }\n</style>    \n"]}]}